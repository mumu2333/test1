预处理：头文件展开，宏替换，去除注释，条件编译
编译：词法分析，语法分析，语义分析，符号汇总，生成汇编代码
汇编：将汇编代码转换为二进制机器码，形成对应的符号表
连接：合并段表，符号表的重定位

指针数组

联系：
1.表达式中的数组名就是指针
2.数组中的下标就是指针的偏移量
3.作为函数参数的数组名就是指针


区别：

1.数组名在传参时会退化为指针，指针不会
2.在内存中数组表示一块连续的空间，指针表示一个指针大小的空间4字节
8字节
3.数组可以通过下标直接访问，指针需要进行计算间接访问
4.数组名具有常属性，不能进行++ --操作，指针可以
5.sizeof数组名，sizeof指针

数组名不能作为左值

宏

宏的优点：
执行速度快，在预处理阶段完成替换

宏的缺点：

1.多出调用宏，可能会造成代码膨胀
2.宏没有类型检查
3.宏有算数优先级问题，需要多加括号
4.宏补不能调试
5.带有副作用的宏参数进行多次求值，可能得到意料之外的结果++，--


宏和函数比较：

代码长度：

多次使用宏会使得代码长度大幅增长

函数代码只出现在一个地方，每次调用，都会跳转到该函数

执行速度：

宏在预处理阶段完成宏替换

函数需要创建栈帧，压参传参，返回值的开销


操作符优先级：

宏有操作数优先级问题，函数没有

参数求值：

宏每出现一次，重新求值一次
函数调用前计算一次，不会出现副作用；

参数类型：

宏没有类型检查，函数有
函数可以实现重载


宏和枚举：

宏在预处理阶段替换，枚举在编译阶段确定值

宏不能调试，枚举可以

枚举一次可以定义大量常量，宏一次只能定义一个


宏和内联函数：

宏在预处理阶段替换，内联在编译阶段
宏一定会替换，内联只是一个建议，由编译器决定是否替换
宏不做类型检查，内联进行；
宏会出现优先级问题

static:

修饰变量：

生命周期为到程序结束位置；

静态全局变量失去外部链接属性

存放在静态区

修饰函数

失去外部链接属性
作用域仅限本文件，避免了和别人的文件名冲突

const:

修饰变量，表示变量具有常属性，不可改变，实际可通过指针修改
实际并不是常量

编译器通常保存在符号表中，不为其开辟空间

修饰指针：

char  const *         const char*  表示指针指向的内容不能改变

char*  const  表示指针的指向不能改变

const int* const  p    p 和*p都不能改变

修饰函数参数，表名该参数不能修改

修饰返回值，表示返回值不能修改


函数传参：

传参方式：

值传递     值传递，函数获得了实参的临时拷贝
地址传递  地址传递，函数获得了参数的地址

数组传参，退化为指针，指向数组的首元素地址

多维数组传参，需要提供最左边的一维之外的其他维长度


指针传参，要想修改指针的指向，可传递二级指针



结构体：


内存对齐：

原因:    减少访问此时，提高性能

原则：

第一个成员偏移量为0，

之后的成员的偏移量为，#pragma pack大小（Linux为4，windows为8）和成员大小中的较小者的整数倍；

结构体的大小为所有成员的偏移量的最大值的整数倍


为什么要对齐：
平台原因，不是所有的硬件平台都能够访问任意地址的数据
性能原因：数据结构尽可能在自然边界上对齐，为了访问未对齐的内存，编译器需要做两次内存访问；

空结构体大小为1

内存地址空间分配：

栈区：保存局部变量，出了作用域自动销毁
堆区：动态内存分配的空间，malloc,free，需要手动释放，有内存泄漏问题

静态区,数据段:已初始化全局变量区，未初始化全局变量区
static ,全局
代码段：保存可执行代码和常量

malloc：注意判断是否申请成功
malloc申请0字节不会反悔NULL，
为什么：
1.0字节大小的对象也是对象；

2.返回NULL会和分配失败混淆，

3.反正返回的地址不能读写，此时可以返回一个固定的地址，并没有什么额外的开销，

4.不管返回的是不是空，都可以free;

free只将内存释放，不会将指针置为空；

malloc 的次数必须和free的次数相等；


函数栈帧：



const 修饰成员函数，其实是修饰了成员函数的默认第一个参数this指针所指向的对象，表示这个对象在函数内不能被改变


inline修饰函数表示该函数为内联函数

1.inline只是一个建议，编译器会自动选择到底要不要设置该函数为内联函数。

2.在编译期间，编译器会将内联函数展开

3.定义在类内部的成员函数默认为内联函数

4.debug版本没有正真的内联函数，在release版本中有内联真正的函数

内联不适用情况：

1.函数体较长
2.函数体出现循环，递归，switch语句


友元函数：

前面加friend

友元函数不是类的成员函数
友元函数允许在类外访问该类的任何成员
友元函数破坏了封装性

类的static:

类中由static修饰的成员为静态成员

类的静态成员属于类，为该类的所有对象所共享；

类的静态成员变量在类外定义并初始化

静态成员函数没有this指针，使用类的类型名::函数名

类的静态成员函数内部不可以使用类的非静态成员函数，


类对象的建立：

A a    通过调用构造函数实例化对象，在栈中分配内存
A* pa = new A(4)   通过operator new()函数，在堆中分配内存，再调用构造函数构造对象，初始化内存空间


如何只能在堆上创建一个对象，

将析构函数设为私有
编译器为类对象分配内存时，会先检查类的析构函数的访问性，如果类的析构函数为私有的，则编译器不会在栈上分配内存

只有使用new 运算符才会建立在堆上，只要禁用new运算符，就可以实现类只能建立在栈上，将operator new设为私有

构造函数，对象构造或者实例化时系统自动调用
可重载
缺省的构造函数只能有一个

初始化列表：
const成员变量
引用成员变量
没有缺省构造的类成员变量

初始化顺序：按声明顺序初始化

拷贝构造函数必须使用引用传参
如果为传值，那么在传参的过程中就又会发生一次拷贝，再次调用拷贝构造函数，会递归到奔溃

析构函数，对象的生命周期结束，自动调用

赋值运算符

赋值运算符是对已有的对象进行拷贝赋值
拷贝构造函数时用已有的对象初始化这个准备创建的对象

返回值为引用，是为了支持链式赋值

calss 和 struct 

默认访问限定符不同

class为private,struct 为 public
继承方式不同
class 为 private继承，struct 为public继承

class 能够定义模板，struct 不能

malloc/free和new/delete区别：

malloc/free为C/C++标准库函数，new/delete为C++操作符
malloc/free只负责动态开辟内存和释放内存，new/delete还要调用构造函数和析构函数进行初始化和

malloc 需要手动计算类型大小，且返回值为void* ,
new可自己计算并返回对应类型的指针

new
调用operator new 申请内存空间
调用构造函数初始化

delete
调用析构函数，清理对象
调用operator delete释放内存空间

new[]
使用 operator new构造4字节空间+所需空间大小，前4字节用来存放元素个数
头指针向后移动，电泳N次构造函数，进行初始化；

delete[]
使头指针向后偏移4字节，调用N次析构函数清理对象
头指针再从头开始，一次性调用operator delete释放空间

只有当自定义类型且自定义析构函数时编译器才会多开4字节存放元素个数

深拷贝：每次直接开辟空间，每个对象指向不同地址；
引用计数的写实

多态：
作用：一个接口，多种实现方式
虚函数的重写、协变:
virtual  函数相同，或满足协变
构成多态和类型无关，与对象有关
虚函数在代码段
